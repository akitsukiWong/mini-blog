{
  "meta": {
    "title": "渣博客",
    "subtitle": "哈哈哈",
    "description": "汪秋月的个人博客",
    "author": "汪秋月",
    "url": "https://akitsukiwong.github.io"
  },
  "pages": [
    {
      "title": "关于我",
      "date": "2018-05-10T16:15:47.000Z",
      "updated": "2018-05-11T06:28:29.737Z",
      "comments": true,
      "path": "about/index.html",
      "permalink": "https://akitsukiwong.github.io/about/index.html",
      "excerpt": "",
      "text": "这是一个渣渣前端的个人博客 个人简历网站版 http://dflxm.oschina.io"
    }
  ],
  "posts": [
    {
      "title": "wepy学习",
      "slug": "wepy",
      "date": "2018-12-07T06:51:00.000Z",
      "updated": "2018-12-07T08:22:01.069Z",
      "comments": true,
      "path": "2018/12/07/wepy/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/12/07/wepy/",
      "excerpt": "",
      "text": "快速入门全局安装1npm install wepy-cli -g 生成Demo开发项目1wepy init standard myproject 安装依赖1npm install 实时编译1wepy build --watch 设置微信开发者工具 选项中关闭ES6转ES5 选项中关闭上传代码时样式自动补全 选项中关闭代码压缩上传 选项中打开不检查安全域名（如果已配置好安全域名则建议关闭） @符号 原 bindtap=&quot;click&quot; 替换为 @tap=&quot;click&quot; 原catchtap=&quot;click&quot; 替换为 `@tap.stop=”click”` 原 capture-bind:tap=&quot;click&quot; 替换为 `@tap.capture=”click”` 原capture-catch:tap=&quot;click&quot;替换为`@tap.capture.stop=”click”`",
      "categories": [],
      "tags": [
        {
          "name": "wepy",
          "slug": "wepy",
          "permalink": "https://akitsukiwong.github.io/tags/wepy/"
        }
      ]
    },
    {
      "title": "vue生命周期钩子",
      "slug": "vue生命周期钩子",
      "date": "2018-10-25T06:55:17.000Z",
      "updated": "2018-10-25T06:55:17.152Z",
      "comments": true,
      "path": "2018/10/25/vue生命周期钩子/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/10/25/vue生命周期钩子/",
      "excerpt": "",
      "text": "",
      "categories": [],
      "tags": []
    },
    {
      "title": "SQL语句学习",
      "slug": "SQL语句学习",
      "date": "2018-10-25T06:55:00.000Z",
      "updated": "2018-12-07T08:22:22.162Z",
      "comments": true,
      "path": "2018/10/25/SQL语句学习/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/10/25/SQL语句学习/",
      "excerpt": "",
      "text": "SQL语句学习上周试着用Express去搭后台 , 搭好了一个基础的框架 , 后端还是挺有意思的 我如果需要更丰富的功能就需要学习更多的SQL语句 , 所以这周的计划是学习SQL语句 学习的主要途径是看W3C的文档 链接 SQL 简介SQL 是用于访问和处理数据库的标准的计算机语言。 什么是 SQL？ SQL 指结构化查询语言 SQL 使我们有能力访问数据库 SQL 是一种 ANSI (美国国家标准化组织) 的标准计算机语言 SQL 能做什么？ SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 SQL 语法数据库表一个数据库通常包含一个或多个表。每个表由一个名字标识（例如“客户”或者“订单”）。表包含带有数据的记录（行）。 下面的例子是一个名为 “Persons” 的表： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 上面的表包含三条记录（每一条对应一个人）和五个列（Id、姓、名、地址和城市）。 SQL 语句您需要在数据库上执行的大部分工作都由 SQL 语句完成。 下面的语句从表中选取 LastName 列的数据： 1SELECT LastName FROM Persons 结果集类似这样： LastName Adams Bush Carter 在本教程中，我们将为您讲解各种不同的 SQL 语句。 重要事项 : 一定要记住，SQL 对大小写不敏感！ SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。 SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。 查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。 SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT 语句SQL SELECT 语句SELECT 语句用于从表中选取数据。 结果被存储在一个结果表中（称为结果集）。 SQL SELECT 语法1SELECT 列名称 FROM 表名称 以及： 1SELECT * FROM 表名称 注释：SQL 语句对大小写不敏感。SELECT 等效于 select。 SQL SELECT 实例如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句： 1SELECT LastName,FirstName FROM Persons “Persons” 表: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 结果： LastName FirstName Adams John Bush George Carter Thomas SQL SELECT * 实例现在我们希望从 “Persons” 表中选取所有的列。 请使用符号 * 取代列的名称，就像这样： 1SELECT * FROM Persons 提示：星号（*）是选取所有列的快捷方式。 结果： Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing SQL SELECT DISTINCT 语句SQL SELECT DISTINCT 语句在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。 语法： 1SELECT DISTINCT 列名称 FROM 表名称 使用 DISTINCT 关键词如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT Company FROM Orders “Orders”表： Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 结果： Company IBM W3School Apple W3School 请注意，在结果集中，W3School 被列出了两次。 如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT Company FROM Orders 现在，在结果集中，”W3School” 仅被列出了一次。 SQL WHERE 子句WHERE 子句用于规定选择的标准。WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。 语法 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。 使用 WHERE 子句如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句： 1SELECT * FROM Persons WHERE City=&apos;Beijing&apos; “Persons” 表 LastName FirstName Address City Year Adams John Oxford Street London 1970 Bush George Fifth Avenue New York 1975 Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 结果： LastName FirstName Address City Year Carter Thomas Changan Street Beijing 1980 Gates Bill Xuanwumen 10 Beijing 1985 引号的使用 请注意，我们在例子中的条件值周围使用的是单引号。 SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。 文本值： 12345这是正确的：SELECT * FROM Persons WHERE FirstName=&apos;Bush&apos;这是错误的：SELECT * FROM Persons WHERE FirstName=Bush 数值： 12345这是正确的：SELECT * FROM Persons WHERE Year&gt;1965这是错误的：SELECT * FROM Persons WHERE Year&gt;&apos;1965&apos; SQL AND &amp; OR 运算符AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。AND 和 OR 运算符AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 原始的表 (用在例子中的)： LastName FirstName Address City Adams John Oxford Street London Bush George Fifth Avenue New York Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing AND 运算符实例使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing OR 运算符实例使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人： 1SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing 结合 AND 和 OR 运算符我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）: 12SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;)AND LastName=&apos;Carter&apos; 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Carter William Xuanwumen 10 Beijing SQL ORDER BY 子句ORDER BY 语句用于对结果集进行排序。ORDER BY 语句ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 原始的表 (用在例子中的)： Orders 表: Company OrderNumber IBM 3532 W3School 2356 Apple 4698 W3School 6953 实例 1 以字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 6953 W3School 2356 实例 2 以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber 结果： Company OrderNumber Apple 4698 IBM 3532 W3School 2356 W3School 6953 实例 3 以逆字母顺序显示公司名称： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC 结果： Company OrderNumber W3School 6953 W3School 2356 IBM 3532 Apple 4698 实例 4 以逆字母顺序显示公司名称，并以数字顺序显示顺序号： 1SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC 结果： Company OrderNumber W3School 2356 W3School 6953 IBM 3532 Apple 4698 注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。 SQL INSERT INTO 语句INSERT INTO 语句用于向表格中插入新的行。 1INSERT INTO 表名称 VALUES (值1, 值2,....) 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)",
      "categories": [],
      "tags": [
        {
          "name": "SQL",
          "slug": "SQL",
          "permalink": "https://akitsukiwong.github.io/tags/SQL/"
        }
      ]
    },
    {
      "title": "Document 节点",
      "slug": "Document-节点",
      "date": "2018-09-29T00:47:00.000Z",
      "updated": "2018-12-07T08:22:35.400Z",
      "comments": true,
      "path": "2018/09/29/Document-节点/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/Document-节点/",
      "excerpt": "",
      "text": "Document 节点概述document节点对象代表整个文档，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。 document对象有不同的办法可以获取。 正常的网页，直接使用document或window.document。iframe框架里面的网页，使用iframe节点的contentDocument属性。Ajax操作返回的文档，使用XMLHttpRequest对象的responseXML属性。内部节点的ownerDocument属性。document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。 属性快捷方式属性以下属性是指向文档内部的某个节点的快捷方式。 （1）document.defaultViewdocument.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 1document.defaultView === window // true （2）document.doctype对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 123var doctype = document.doctype;doctype // &quot;&lt;!DOCTYPE html&gt;&quot;doctype.name // &quot;html&quot; document.firstChild通常就返回这个节点。 （3）document.documentElementdocument.documentElement属性返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是节点。 （4）document.body，document.headdocument.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。 这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 （5）document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。 标准模式下，这个属性返回的文档的根元素document.documentElement（即）。兼容（quirk）模式下，返回的是元素，如果该元素不存在，返回null。 12// 页面滚动到浏览器顶部document.scrollingElement.scrollTop = 0; （6）document.activeElementdocument.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。 （7）document.fullscreenElementdocument.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 123if (document.fullscreenElement.nodeName == &apos;VIDEO&apos;) &#123; console.log(&apos;全屏播放视频&apos;);&#125; 上面代码中，通过document.fullscreenElement可以知道&lt;video&gt;元素有没有处在全屏状态，从而判断用户行为。 节点集合属性以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。 （1）document.linksdocument.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。 12345// 打印文档所有的链接var links = document.links;for(var i = 0; i &lt; links.length; i++) &#123; console.log(links[i]);&#125; （2）document.formsdocument.forms属性返回所有&lt;form&gt; 表单节点。 1var selectForm = document.forms[0]; 上面代码获取文档第一个表单。 除了使用位置序号，id属性和name属性也可以用来引用表单。 12345/* HTML 代码如下 &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;*/document.forms[0] === document.forms.foo // truedocument.forms.bar === document.forms.foo // true （3）document.imagesdocument.images属性返回页面所有图片节点。 1234567var imglist = document.images;for(var i = 0; i &lt; imglist.length; i++) &#123; if (imglist[i].src === &apos;banner.gif&apos;) &#123; // ... &#125;&#125; 上面代码在所有img标签中，寻找某张图片。 （4）document.embeds，document.pluginsdocument.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。 （5）document.scriptsdocument.scripts属性返回所有&lt;script&gt;节点。 1234var scripts = document.scripts;if (scripts.length !== 0 ) &#123; console.log(&apos;当前网页有脚本&apos;);&#125; （6）document.styleSheetsdocument.styleSheets属性返回文档内嵌或引入的样式表集合 （7）小结除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。 12345document.links instanceof HTMLCollection // truedocument.images instanceof HTMLCollection // truedocument.forms instanceof HTMLCollection // truedocument.embeds instanceof HTMLCollection // truedocument.scripts instanceof HTMLCollection // true HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 123// HTML 代码如下// &lt;form name=&quot;myForm&quot;&gt;document.myForm === document.forms.myForm // true 文档静态信息属性以下属性返回文档信息。 （1）document.documentURI，document.URLdocument.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 12345document.URL// http://www.example.com/aboutdocument.documentURI === document.URL// true 如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。 （2）document.domaindocument.domain属性返回当前文档的域名，不包含协议和接口。比如，网页的网址是http://www.example.com:80/hello.html，那么domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。 另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。 （3）document.locationLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 （4）document.lastModifieddocument.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 12document.lastModified// &quot;03/07/2018 11:18:27&quot; 注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。 1234var lastVisitedDate = Date.parse(&apos;01/01/2018&apos;);if (Date.parse(document.lastModified) &gt; lastVisitedDate) &#123; console.log(&apos;网页已经变更&apos;);&#125; 如果页面上有 JavaScript 生成的内容，document.lastModified属性返回的总是当前时间。 （5）document.titledocument.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 12document.title = &apos;新标题&apos;;document.title // &quot;新标题&quot; （6）document.characterSetdocument.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 （7）document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 12document.referrer// &quot;https://example.com/path&quot; 如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。 document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r。 （8）document.dirdocument.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 ####（9）document.compatMode compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。 文档状态属性（1）document.hiddendocument.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。 （2）document.visibilityStatedocument.visibilityState返回文档的可见状态。 它的值有四种可能。 visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。 hidden： 页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。 prerender：页面处于正在渲染状态，对于用于来说，该页面不可见。 unloaded：页面从内存里面卸载了。 这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。 （3）document.readyStatedocument.readyState属性返回当前文档的状态，共有三种可能的值。 loading：加载 HTML 代码阶段（尚未完成解析） interactive：加载外部资源阶段 complete：加载完成 这个属性变化的过程如下。 浏览器开始解析 HTML 文档，document.readyState属性等于loading。 浏览器遇到 HTML 文档中的&lt;script&gt;元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。 HTML 文档解析完成，document.readyState属性变成interactive。 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。 下面的代码用来检查网页是否加载成功。 123456789101112// 基本检查if (document.readyState === &apos;complete&apos;) &#123; // ...&#125;// 轮询检查var interval = setInterval(function() &#123; if (document.readyState === &apos;complete&apos;) &#123; clearInterval(interval); // ... &#125;&#125;, 100); 另外，每次状态变化都会触发一个readystatechange事件。 document.cookiedocument.cookie属性用来操作浏览器 Cookie document.designModedocument.designMode属性控制当前文档是否可编辑。该属性只有两个值on和off，默认值为off。一旦设为on，用户就可以编辑整个文档的内容。 下面代码打开iframe元素内部文档的designMode属性，就能将其变为一个所见即所得的编辑器。 1234// HTML 代码如下// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;var editor = document.getElementById(&apos;editor&apos;);editor.contentDocument.designMode = &apos;on&apos;; document.implementationdocument.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 DOMImplementation.createDocument()：创建一个 XML 文档。 DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。 DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。 下面是创建 HTML 文档的例子。 123456789var doc = document.implementation.createHTMLDocument(&apos;Title&apos;);var p = doc.createElement(&apos;p&apos;);p.innerHTML = &apos;hello world&apos;;doc.body.appendChild(p);document.replaceChild( doc.documentElement, document.documentElement); 上面代码中，第一步生成一个新的 HTML 文档doc，然后用它的根元素document.documentElement替换掉document.documentElement。这会使得当前文档的内容全部消失，变成hello world。 方法document.open()，document.close()document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 document.close方法用来关闭document.open()打开的文档。 123document.open();document.write(&apos;hello world&apos;);document.close(); document.write()，document.writeln()document.write方法用于向当前文档写入内容。 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 12345// 页面显示“helloworld”document.open();document.write(&apos;hello&apos;);document.write(&apos;world&apos;);document.close(); 注意，document.write会当作 HTML 代码解析，不会转义。 1document.write(&apos;&lt;p&gt;hello world&lt;/p&gt;&apos;); 上面代码中，document.write会将&lt;p&gt;当作 HTML 标签解释。 如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 12345678910document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;);&#125;);// 等同于document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.open(); document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;); document.close();&#125;); 如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。） 12345678&lt;html&gt;&lt;body&gt;hello&lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;world&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器打开上面网页，将会显示hello world。 document.write是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。 document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。 123456789document.write(1);document.write(2);// 12document.writeln(1);document.writeln(2);// 1// 2// 注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入&lt;br&gt;。 document.querySelector()，document.querySelectorAll()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 12var el1 = document.querySelector(&apos;.myclass&apos;);var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。 1234elementList = document.querySelectorAll(&apos;.myclass&apos;);``` 这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。 var matches = document.querySelectorAll(‘div.note, div.alert’);1234上面代码返回`class`属性是`note`或`alert`的`div`元素。这两个方法都支持复杂的 CSS 选择器。 // 选中 data-foo-bar 属性等于 someval 的元素document.querySelectorAll(‘[data-foo-bar=”someval”]’); // 选中 myForm 表单中所有不通过验证的元素document.querySelectorAll(‘#myForm :invalid’); // 选中div元素，那些 class 含 ignore 的除外document.querySelectorAll(‘DIV:not(.ignore)’); // 同时选中 div，a，script 三类元素document.querySelectorAll(‘DIV, A, SCRIPT’);12345678910但是，它们不支持 CSS 伪元素的选择器（比如`:first-line`和`:first-letter`）和伪类的选择器（比如`:link`和`:visited`），即无法选中伪元素和伪类。如果`querySelectorAll`方法的参数是字符串`*`，则会返回文档中的所有元素节点。另外，`querySelectorAll`的返回结果不是动态集合，不会实时反映元素节点的变化。最后，这两个方法除了定义在`document`对象上，还定义在元素节点上，即在元素节点上也可以调用。### document.getElementsByTagName()`document.getElementsByTagName`方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection`实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 var paras = document.getElementsByTagName(‘p’);paras instanceof HTMLCollection // true123456上面代码返回当前文档的所有`p`元素节点。HTML 标签名是大小写不敏感的，因此`getElementsByTagName`方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。如果传入`*`，就可以返回文档中所有 HTML 元素。 var allElements = document.getElementsByTagName(‘*’);12注意，元素节点本身也定义了`getElementsByTagName`方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。 var firstPara = document.getElementsByTagName(‘p’)[0];var spans = firstPara.getElementsByTagName(‘span’);123456上面代码选中第一个`p`元素内部的所有`span`元素。### document.getElementsByClassName()`document.getElementsByClassName`方法返回一个类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。 var elements = document.getElementsByClassName(names);1234由于`class`是保留字，所以 JavaScript 一律使用`className`表示 CSS 的`class`。参数可以是多个`class`，它们之间使用空格分隔。 var elements = document.getElementsByClassName(‘foo bar’);12345678910上面代码返回同时具有`foo`和`bar`两个`class`的元素，`foo`和`bar`的顺序不重要。注意，正常模式下，CSS 的`class`是大小写敏感的。（`quirks mode`下，大小写不敏感。）与`getElementsByTagName`方法一样，`getElementsByClassName`方法不仅可以在`document`对象上调用，也可以在任何元素节点上调用。### document.getElementsByName() `document.getElementsByName`方法用于选择拥有`name`属性的 HTML 元素（比如`&lt;form&gt;`、`&lt;radio&gt;`、`&lt;img&gt;`、`&lt;frame&gt;`、`&lt;embed&gt;`和`&lt;object&gt;`等），返回一个类似数组的的对象（`NodeList`实例），因为`name`属性相同的元素可能不止一个。 // 表单为 var forms = document.getElementsByName(‘x’);forms[0].tagName // “FORM”1234### document.getElementById()`document.getElementById`方法返回匹配指定`id`属性的元素节点。如果没有发现匹配的节点，则返回`null`。 var elem = document.getElementById(‘para1’);1234注意，该方法的参数是大小写敏感的。比如，如果某个节点的`id`属性是`main`，那么`document.getElementById(&apos;Main&apos;)`将返回`null`。`document.getElementById`方法与`document.querySelector`方法都能获取元素节点，不同之处是`document.querySelector`方法的参数使用 CSS 选择器语法，`document.getElementById`方法的参数是元素的`id`属性。 document.getElementById(‘myElement’)document.querySelector(‘#myElement’)12345678上面代码中，两个方法都能选中`id`为`myElement`的元素，但是`document.getElementById()`比`document.querySelector()`效率高得多。另外，这个方法只能在`document`对象上使用，不能在其他元素节点上使用。### document.elementFromPoint()，document.elementsFromPoint() `document.elementFromPoint`方法返回位于页面指定位置最上层的元素节点。 var element = document.elementFromPoint(50, 50);123456上面代码选中在(50, 50)这个坐标位置的最上层的那个 HTML 元素。elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 var elements = document.elementsFromPoint(x, y);1234### document.caretPositionFromPoint()`document.caretPositionFromPoint()`返回一个 `CaretPosition` 对象，包含了指定坐标点在节点对象内部的位置信息。`CaretPosition` 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。 var range = document.caretPositionFromPoint(clientX, clientY);12345678910上面代码中，`range`是指定坐标点的 `CaretPosition` 对象。该对象有两个属性。- CaretPosition.offsetNode：该位置的节点对象- CaretPosition.offset：该位置在offsetNode对象内部，与起始位置相距的字符数。### document.createElement()`document.createElement`方法用来生成元素节点，并返回该节点。 var newDiv = document.createElement(‘div’);12`createElement`方法的参数为元素的标签名，即元素节点的`tagName`属性，对于 HTML 网页大小写不敏感，即参数为`div`或`DIV`返回的是同一种节点。如果参数里面包含尖括号（即`&lt;`和`&gt;`）会报错。 document.createElement(‘‘);// DOMException: The tag name provided (‘‘) is not a valid name12注意，`document.createElement`的参数可以是自定义的标签名。 document.createElement(‘foo’);1234### document.createTextNode()`document.createTextNode`方法用来生成文本节点（`Text`实例），并返回该节点。它的参数是文本节点的内容。 var newDiv = document.createElement(‘div’);var newContent = document.createTextNode(‘Hello’);newDiv.appendChild(newContent);1234上面代码新建一个`div`节点和一个文本节点，然后将文本节点插入`div`节点。这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。 var div = document.createElement(‘div’);div.appendChild(document.createTextNode(‘Foo &amp; bar‘));console.log(div.innerHTML)// &lt;span&gt;Foo &amp; bar&lt;/span&gt;1234上面代码中，`createTextNode`方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。 function escapeHtml(str) { var div = document.createElement(‘div’); div.appendChild(document.createTextNode(str)); return div.innerHTML;}; var userWebsite = ‘“ onmouseover=”alert(\\’derp\\’)” “‘;var profileLink = ‘Bob‘;var div = document.getElementById(‘target’);div.innerHTML = profileLink;// Bob123456上面代码中，由于`createTextNode`方法不转义双引号，导致`onmouseover`方法被注入了代码。### document.createAttribute() `document.createAttribute`方法生成一个新的属性节点（`Attr`实例），并返回它。 var attribute = document.createAttribute(name);12`document.createAttribute`方法的参数`name`，是属性的名称。 var node = document.getElementById(‘div1’); var a = document.createAttribute(‘my_attrib’);a.value = ‘newVal’; node.setAttributeNode(a);// 或者node.setAttribute(‘my_attrib’, ‘newVal’);123456上面代码为`div1`节点，插入一个值为`newVal`的`my_attrib`属性。### document.createComment() `document.createComment`方法生成一个新的注释节点，并返回该节点。 var CommentNode = document.createComment(data);`",
      "categories": [],
      "tags": [
        {
          "name": "js",
          "slug": "js",
          "permalink": "https://akitsukiwong.github.io/tags/js/"
        }
      ]
    },
    {
      "title": "面向对象编程",
      "slug": "面向对象编程",
      "date": "2018-09-29T00:46:17.000Z",
      "updated": "2018-09-29T00:46:24.577Z",
      "comments": true,
      "path": "2018/09/29/面向对象编程/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/面向对象编程/",
      "excerpt": "",
      "text": "面向对象编程 实例对象与 new 命令 this 关键字 对象的继承 Object 对象的相关方法 严格模式 实例对象与 new 命令JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。 1. 对象是什么面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 那么，“对象”（object）到底是什么？我们从两个层次来理解。 （1）对象是单个实物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 （2）对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 2. 构造函数面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 下面先介绍new命令。 3. new 命令3.1 基本用法new 命令的作用，就是执行构造函数，返回一个实例对象。 123456var Vehicle = function () &#123; this.price = 1000;&#125;;var v = new Vehicle();v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。 使用new命令时，根据需要，构造函数也可以接受参数。 12345var Vehicle = function (p) &#123; this.price = p;&#125;;var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。 1234// 推荐的写法var v = new Vehicle();// 不推荐的写法var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？ 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 12345678function Fubar(foo, bar)&#123; &apos;use strict&apos;; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property &apos;_foo&apos; of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。 3.2 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 1234567var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000// false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。 1234567var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price// 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 12345678function getMessage() &#123; return &apos;this is a message&apos;;&#125;var msg = new getMessage();msg // &#123;&#125;typeof msg // &quot;object&quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。 new命令简化的内部流程，可以用下面的代码表示。 123456789101112131415function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === &apos;object&apos; &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, &apos;张三&apos;, 28); 3.3 new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 123456function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true 使用这个属性，可以判断函数调用的时候，是否使用new命令。 12345678function f() &#123; if (!new.target) &#123; throw new Error(&apos;请使用 new 命令调用！&apos;); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ 上面代码中，构造函数f调用时，没有使用new命令，就抛出一个错误。 4. Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 123456789101112var person1 = &#123; name: &apos;张三&apos;, age: 38, greeting: function() &#123; console.log(&apos;Hi! I\\&apos;m &apos; + this.name + &apos;.&apos;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&apos;m 张三. 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 this 关键字1. 涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 前一章已经提到，this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。 简单说，this就是属性或方法“当前”所在的对象。 1this.property 上面代码中，this就代表property属性当前所在的对象。 下面是一个实际的例子。 123456789var person = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;person.describe()// &quot;姓名：张三&quot; 上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 1234567891011121314var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;B.describe = A.describe;B.describe()// &quot;姓名：李四&quot; 上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。 稍稍重构这个例子，this的动态指向就能看得更清楚。 12345678910111213141516function f() &#123; return &apos;姓名：&apos;+ this.name;&#125;var A = &#123; name: &apos;张三&apos;, describe: f&#125;;var B = &#123; name: &apos;李四&apos;, describe: f&#125;;A.describe() // &quot;姓名：张三&quot;B.describe() // &quot;姓名：李四&quot; 上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。 12345678910var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var name = &apos;李四&apos;;var f = A.describe;f() // &quot;姓名：李四&quot; 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 再看一个网页编程的例子。 12345678&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;&lt;script&gt;function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log(&apos;Invalid Value!&apos;);&#125;&lt;/script&gt; 上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此this就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 2. 实质JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() JavaScript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x；在obj环境执行，this.x指向obj.x。 3. 使用场合this主要有以下几个使用场合。 （1）全局环境 全局环境使用this，它指的就是顶层对象window。 123456this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 （2）构造函数 构造函数中的this，指的是实例对象。 123var Obj = function (p) &#123; this.p = p;&#125;; 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。 12var o = new Obj(&apos;Hello World!&apos;);o.p // &quot;Hello World!&quot; （3）对象的方法 如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 但是，这条规则很不容易把握。请看下面的代码。 1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，下面这几种用法，都会改变this的指向。 123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。 12345678910var a = &#123; p: &apos;Hello&apos;, b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。 123456789101112var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: &apos;Hello&apos;, b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。 12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。 12var hello = a.b;hello.m() // Hello 4. 使用注意点4.1 避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。 123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。 12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。 12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; &apos;use strict&apos;; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 4.2 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。 1234567891011121314var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+&apos; &apos;+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 4.3 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。 1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, o.f); 上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 5. 绑定 this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 5.1 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 123456789101112var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法将this关键字指向obj对象，返回结果为456。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。 1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。 call方法的一个应用是调用对象的原生方法。 12345678910var obj = &#123;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // trueObject.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 5.2 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 123456function f(x, y)&#123; console.log(x + y);&#125;f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 2 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。 利用这一点，可以做一些有趣的应用。 （1）找出数组最大元素 JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。 12var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15 （2）将数组的空元素变为undefined 通过apply方法，利用Array构造函数将数组的空元素变成undefined。 12Array.apply(null, [&apos;a&apos;, ,&apos;b&apos;])// [ &apos;a&apos;, undefined, &apos;b&apos; ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 1234567891011121314var a = [&apos;a&apos;, , &apos;b&apos;];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b （3）转换类似数组的对象 另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 1234Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]Array.prototype.slice.apply(&#123;0: 1&#125;) // []Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 （4）绑定回调函数的对象 前面的按钮点击事件的例子，可以改写如下。 12345678910111213var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, f); 上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。 5.3 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题。 12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。 this绑定到其他对象也是可以的。 12345678910111213var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 1234567891011var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。 123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 bind方法有一些使用注意点。 （1）每一次返回一个新函数 bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。 1element.addEventListener(&apos;click&apos;, o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。 1element.removeEventListener(&apos;click&apos;, o.m.bind(o)); 正确的方法是写成下面这样： 1234var listener = o.m.bind(o);element.addEventListener(&apos;click&apos;, listener);// ...element.removeEventListener(&apos;click&apos;, listener); （2）结合回调函数使用 回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。 1234567891011121314var counter = &#123; count: 0, inc: function () &#123; &apos;use strict&apos;; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 123456789101112var obj = &#123; name: &apos;张三&apos;, times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 （3）结合call方法使用 利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。 123[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。 12var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法。 123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。 1234567function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码的含义就是，将Function.prototype.bind方法绑定在Function.prototype.call上面，所以bind方法就可以直接使用，不需要在函数实例上使用。",
      "categories": [],
      "tags": []
    },
    {
      "title": "nginx反向代理",
      "slug": "nginx反向代理",
      "date": "2018-09-29T00:45:22.000Z",
      "updated": "2018-09-29T00:45:22.756Z",
      "comments": true,
      "path": "2018/09/29/nginx反向代理/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/nginx反向代理/",
      "excerpt": "",
      "text": "###nginx反向代理 1.下载nginx http://nginx.org/en/download.html 下载稳定版本，以nginx/Windows-1.12.2为例，直接下载 nginx-1.12.2.zip 2.启动nginx 有很多种方法启动nginx (1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过 (2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe 或者 start nginx ，回车即可 3.检查nginx是否启动成功 直接在浏览器地址栏输入网址 http://localhost:80，回车，出现以下页面说明启动成功 反向代理1.定义 跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！ 2.跨域访问示例 假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。 关于nginx的配置可以查看另一篇博文：http://www.cnblogs.com/renjing/p/6126284.html。找到nginx的配置文件“nginx.conf”，修改一下信息 123456789101112131415161718server &#123; listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://localhost:81; proxy_redirect default; &#125; location /apis &#123; #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; &#125;#以下配置省略 配置解释： 1.由配置信息可知，我们让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。 2.我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址都转到“http://localhost:82”进行处理。 3.rewrite ^/apis/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.*)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 break代表匹配一个之后停止匹配。 访问地址修改 既然配置了nginx，那么所有的访问都要走nginx，而不是走网站原本的地址（A网站localhost:81,B网站localhost:82）。所以要修改A网站中的ajax访问地址，把访问地址由 “http://localhost:82/api/values”改成》》》“/apis/api/values”。",
      "categories": [],
      "tags": []
    },
    {
      "title": "webpack之proxyTable设置跨域",
      "slug": "webpack之proxyTable设置跨域",
      "date": "2018-09-29T00:44:03.000Z",
      "updated": "2018-09-29T00:44:21.900Z",
      "comments": true,
      "path": "2018/09/29/webpack之proxyTable设置跨域/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/webpack之proxyTable设置跨域/",
      "excerpt": "",
      "text": "###webpack之proxyTable设置跨域 使用vue-cli搭建的vue项目可以使用在项目内设置代理（proxyTable）的方式来解决跨域问题。 123456789proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://www.ykt.com/&apos;,//接口域名 changeOrigin: true,//是否跨域 pathRewrite: &#123; &apos;^/api&apos;: &apos;/index/index&apos;//需要rewrite重写 &#125; &#125; &#125; 实现效果： 1localhost:8080/api/getbuildcate ===&gt; www.ykt.com/index/index/getbuildcate",
      "categories": [],
      "tags": []
    },
    {
      "title": "SPA （单页应用程序）",
      "slug": "SPA-（单页应用程序）",
      "date": "2018-09-29T00:42:59.000Z",
      "updated": "2018-09-29T00:44:50.332Z",
      "comments": true,
      "path": "2018/09/29/SPA-（单页应用程序）/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/SPA-（单页应用程序）/",
      "excerpt": "",
      "text": "#SPA （单页应用程序） 先简单复制粘贴一下什么是SPA 百度百科单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 应用介绍单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 特点速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。 笔记初次学习vue-cli做的SPA代码在这 记个笔记 一. 流程1. 全局安装 vue-cli1npm install -g vue-cli 2. 初始化1vue init webpack 项目名称 3. 安装模块1npm install 4. 启动服务器1npm run dev 5. 打包1npm run build",
      "categories": [],
      "tags": []
    },
    {
      "title": "JS语法专题",
      "slug": "JS语法专题",
      "date": "2018-09-29T00:40:19.000Z",
      "updated": "2018-09-29T00:40:36.549Z",
      "comments": true,
      "path": "2018/09/29/JS语法专题/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/29/JS语法专题/",
      "excerpt": "",
      "text": "https://wangdoc.com/javascript/features/index.html 语法专题 数据类型的转换 错误处理机制 编程风格 console 对象与控制台 数据类型的转换1. 概述JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 1var x = y ? 1 : &apos;a&apos;; 上面代码中，变量x到底是数值还是字符串，取决于另一个变量y的值。y为true时，x是一个数值；y为false时，x是一个字符串。这意味着，x的类型没法在编译阶段就知道，必须等到运行时才能知道。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 1&apos;4&apos; - &apos;3&apos; // 1 上面代码中，虽然是两个字符串相减，但是依然会得到结果数值1，原因就在于 JavaScript 将运算子自动转为了数值。 本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。 2. 强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 2.1 Number()使用Number函数，可以将任意类型的值转化成数值。 下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 （1）原始类型值 原始类型值的转换规则如下。 123456789101112131415161718192021// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0 Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\\t\\v\\r12.34\\n&apos;) // 12Number(&apos;\\t\\v\\r12.34\\n&apos;) // 12.34 （2）对象 简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 123Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 请看下面的例子。 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125;",
      "categories": [],
      "tags": []
    },
    {
      "title": "写插件教程",
      "slug": "写插件教程",
      "date": "2018-09-07T06:45:37.000Z",
      "updated": "2018-09-07T06:45:39.366Z",
      "comments": true,
      "path": "2018/09/07/写插件教程/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/07/写插件教程/",
      "excerpt": "",
      "text": "123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #demo-1, #demo-2 &#123; width: 200px; height: 200px; border: 1px solid #ddd; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;点击add可以添加个自input的内容到div里并实现变颜色&lt;/h3&gt; &lt;!--组件实例1--&gt; &lt;div id=&quot;demo-1&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;好的&quot; /&gt; &lt;button id=&quot;add-1&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--组件实例2--&gt; &lt;div id=&quot;demo-2&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;11&quot; /&gt; &lt;button id=&quot;add-2&quot;&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //这里是插件的代码；我为了方便都写到一个html中了；请把这个script标签中的内容单独写在一个js文件里 //整个插件写在一个立即执行函数里；就是function()&#123;&#125;();函数自执行；保证里面的变量不会与外界互相影响 //头部的win啊,doc啊 $ 啊都是底部的window,document,jQuery的映射；方便内部直接调用； //当然你不引用jq的话头部的$和底部的jQuery干掉；你若引用了更过的依赖可以依次添加； //最后面的undefined可不写；最好写了；保证里面再出现的undefined是未定义的意思；不被其他东西赋值； //好了下面是时候展现真正的技术了 //function前的!号(叹号)或者;(分号)这不是写错了,为了防止那个二货写的js结束没有分号；而可能发生报错 /* ;function(win,doc,$,undefined)&#123; &#125;(window,document,jQuery) 或者写在一个闭包里(function()&#123; &#125;()) */ (function(win, doc, undefined) &#123; //我们随便写一个插件吧 比如你要点击按钮 添加input的值到 div里 var addHtml = function(demo, btn) &#123; //插件名，调用的时候直接new一下插件名就行了并传参数或者传对象(一般这个函数名手写字母大写比较好，构造函数嘛，其实也是函数) //很明显我要传id名；这里传什么都可以的其实； this.div = doc.getElementById(demo); //为什么把获取的id传给this.div呢？this的指向为调用的实例；我们此时姑且认为this就指向这个函数；因为这样我们之后再想获取这个div就可以直接用this.div了好吗；而不是在document.getElementById（。。。。） this.btn = doc.getElementById(btn); this.Input = this.div.getElementsByTagName(&quot;input&quot;)[0]; //既然找到了div我们在找下div下面的input；当然你要不input用获取id的形式传参数我没有意见 this.num = 0; //你也可以写一些其他的默认的东西；比如默认的变量啦；方便下面调用；这里写了什么都不会报错；只是有用没用的问题这行可以忽略 this.author = &quot;lianxiaozhuang&quot;; this.init(); //执行下你下面写的函数吧；你想想；如果整个插件没有执行函数；多不好；一堆方法function就不调用；对；这里是调用的时候最开始执行的函数 &#125; //；给构造函数addHtml对象原型里添加属性（方法） addHtml.prototype = &#123; //给函数写方法；这里可能不止一个函数；你还记得你在全局里写一个个的function吗；贼乱； //找也不好找；把一个个函数都写到对象的属性里；调用函数就直接调用对象的属性； constructor: addHtml, //构造器指向构造函数；这行其实不写没啥毛病；不过有时候防止构造器指向Object的情况；你还是装逼写上吧； init: function() &#123; //这里的init；你也可以写成 nimade:function()&#123; &#125;都没有问题；就是在addHtml函数里this.init();执行下；你明白了这里的this了吧；整个插件里this都是只得这个函数（实例）；除非你又引入了其他的函数里的（其他函数里的可能指向就是window了） var _self = this; ////把this保存下来防止在局部函数内部取不到（局部函数内部取得this可能是别的） this.btn.onclick = function() &#123; var _val = _self.Input.value; var tempdiv = doc.createElement(&quot;div&quot;); //创建临时div存放获取input的值 tempdiv.innerHTML = _val; //console.log(tempdiv); _self.div.appendChild(tempdiv); _self.setColor(); //你把所有方法都写在init里绝对没问题；还是那句话；说好的松耦合呢；说好的不写一堆堆的function一层层乱套呢 &#125;; &#125;, setColor: function() &#123; //console.log(this.div) this.div.style.color = &quot;red&quot; &#125; /*, otherFun()&#123; //当然你还可以扩展其他方法；这些方法之间都可以互相调用； 只要用this.方法名 就行了；如果在取不到this比如上面的click函数中的this指向点击的button；只要在写var _self = this;就可以用_self 代替this（函数实例）了；当然_self 也可以写成别的 比如$this等自定义的 &#125;*/ &#125; win.addHtml = addHtml; //把这个对象附给window底下的 名字叫addHtml的对象；要不你调用的时候 new addHtml() 怕在window的环境下找不到； &#125;(window, document)) &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new addHtml(&quot;demo-1&quot;, &quot;add-1&quot;); //这里是实例1调用插件的代码 new addHtml(&quot;demo-2&quot;, &quot;add-2&quot;); //这里是实例2调用插件的代码 //是不是明白为什么要写插件了；要封装；两个相同组件即使有相同的class名在dom操作的时候也不会相互冲突；因为他们都new出来了个自的实例；有自己的this；有自己的一套方法了（其实方法都在原型里是公用的；操作各自的dom） &lt;/script&gt; &lt;!--这里是最简单的插件写法；当然还有传对象参数的插件等等。。。。--&gt; &lt;/body&gt;&lt;/html&gt;",
      "categories": [],
      "tags": []
    },
    {
      "title": "ES6学习笔记",
      "slug": "ES6学习笔记",
      "date": "2018-09-07T01:26:41.000Z",
      "updated": "2018-09-07T01:26:41.513Z",
      "comments": true,
      "path": "2018/09/07/ES6学习笔记/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/07/ES6学习笔记/",
      "excerpt": "",
      "text": "ES6学习笔记ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准 let 和 const 命令1. let命令用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2. 块级作用域为什么要使用块级作用域 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域 let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125;",
      "categories": [],
      "tags": []
    },
    {
      "title": "js数据类型",
      "slug": "js数据类型",
      "date": "2018-09-07T01:25:27.000Z",
      "updated": "2018-09-29T00:37:46.900Z",
      "comments": true,
      "path": "2018/09/07/js数据类型/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/07/js数据类型/",
      "excerpt": "",
      "text": "JS数据类型 概述 null，undefined 和布尔值 数值 字符串 对象 函数 数组 概述简介JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof 运算符 instanceof 运算符 Object.prototype.toString 方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、string、boolean。 123typeof 123 // &quot;number&quot;typeof &apos;123&apos; // &quot;string&quot;typeof false // &quot;boolean&quot; 函数返回function。 123function f() &#123;&#125;typeof f// &quot;function&quot; undefined返回undefined。 12typeof undefined// &quot;undefined 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // &quot;object&quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null, undefined 和布尔值1. null 和 undefined1.1 概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。 1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 上面代码中，null转为数字时，自动变成0。 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 1.2 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 2. 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 两元逻辑运算符：&amp;&amp; (And)，|| (Or) 前置逻辑运算符： !(Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 布尔值往往用于程序流程的控制，请看一个例子。 1234if (&apos;&apos;) &#123; console.log(&apos;true&apos;);&#125;// 没有任何输出 上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 123456789if ([]) &#123; console.log(&apos;true&apos;);&#125;// trueif (&#123;&#125;) &#123; console.log(&apos;true&apos;);&#125;// true 数值1. 概述1.1 整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 1.2 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 1.3 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 2. 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 3. 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 4.特殊数值JavaScript 提供了几个特殊的数值。 4.1 正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。 1234+0 // 0-0 // 0(-0).toString() // &apos;0&apos;(+0).toString() // &apos;0&apos; 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 4.2 NaN4.2.1 含义NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; 4.2.2 运算规则NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN 4.3 Infinity4.3.1 含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false 4.3.2 运算规则Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 5. 与数值相关的全局方法5.1 parseInt()5.1.1 基本用法parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 5.1.2 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 5.2 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\\t\\v\\r12.34\\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN 5.3 isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; 5.4 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串1. 概述1.1 定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \\&apos;Hello\\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \\&quot;Hello\\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = &apos;Long \\long \\long \\string&apos;;longString// &quot;Long long long string&quot; 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\\n&apos;).slice(1, -1).join(&apos;\\n&apos;)// &quot;line 1// line 2// line 3&quot; 上面的例子中，输出的字符串就是多行。 1.2 转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \\0 ：null（\\u0000） \\b ：后退键（\\u0008） \\f ：换页符（\\u000C） \\n ：换行符（\\u000A） \\r ：回车键（\\u000D） \\t ：制表符（\\u0009） \\v ：垂直制表符（\\u000B） \\&#39; ：单引号（\\u0027） \\&quot; ：双引号（\\u0022） \\\\ ：反斜杠（\\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\\n2&apos;)// 1// 2 上面代码中，\\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\\xHH \\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\\uXXXX \\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\\251&apos; // &quot;©&quot;&apos;\\xA9&apos; // &quot;©&quot;&apos;\\u00A9&apos; // &quot;©&quot;&apos;\\172&apos; === &apos;z&apos; // true&apos;\\x7A&apos; === &apos;z&apos; // true&apos;\\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\\\ Next&quot;// &quot;Prev \\ Next&quot; 1.3 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 1.4 length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = &apos;hello&apos;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 2. 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\\u00A9代表版权符号。 12var s = &apos;\\u00A9&apos;;s // &quot;©&quot; 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\\u006F\\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1&apos;𝌆&apos;.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 3. Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa(&apos;你好&apos;) // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象1 概述1.1 生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。 1.2 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = &#123; &apos;foo&apos;: &apos;Hello&apos;, &apos;bar&apos;: &apos;World&apos;&#125;; 如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 上面代码中，对象obj的属性p，就指向一个函数。 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var obj = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中，m属性后面的那个逗号，有没有都可以。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 1.3 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 1.4 表达式还是语句?对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。 12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 2. 属性的操作2.1 属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 2.2 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 1234var obj = &#123;&#125;;obj.foo = &apos;Hello&apos;;obj[&apos;bar&apos;] = &apos;World&apos;; 上面代码中，分别使用点运算符和方括号运算符，对属性赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 2.3 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] 2.4 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 2.5 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 2.6 属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&apos;键名：&apos;, i); console.log(&apos;键值：&apos;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 3. with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 1. 概述1.1 函数的声明JavaScript 有三种声明函数的方法 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 123function print(s) &#123; console.log(s);&#125; 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 1.2 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。 1.3 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。 1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。 1.4 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 12345678910111213function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1)// 2 1.5 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 2. 函数的属性和方法2.1 name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2&quot; 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 2.2 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 2.3 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 3. 函数作用域3.1 定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 3.2 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;;&#125; 3.3 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 1234567891011var x = function () &#123; console.log(a);&#125;;function y(f) &#123; var a = 2; f();&#125;y(x)// ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了“闭包”现象。 4. 参数4.1 概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 123456function square(x) &#123; return x * x;&#125;square(2) // 4square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 4.2 参数的省略函数参数不是必需的，Javascript 允许省略参数。 123456789function f(a, b) &#123; return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 123456function f(a, b) &#123; return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 4.3 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 12345678var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 4.4 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 12345function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 4.5 arguments 对象（1）定义 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 12345678910var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 （2）与数组的关系 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; （3）callee 属性 arguments对象带有一个callee属性，返回它所对应的原函数。 12345var f = function () &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 5. 函数的其他知识点5.1 闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 123456function f1() &#123; var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined( 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125;&#125; 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person(&apos;张三&apos;);p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 5.2 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。 12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。 123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。 1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 6. eval 命令6.1 基本用法eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 12eval(&apos;var a = 1;&apos;);a // 1 上面代码将字符串当作语句运行，生成了变量a。 如果参数字符串无法当作语句运行，那么就会报错。 1eval(&apos;3x&apos;) // Uncaught SyntaxError: Invalid or unexpected token 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。 1eval(&apos;return;&apos;); // Uncaught SyntaxError: Illegal return statement 上面代码会报错，因为return不能单独使用，必须在函数中使用。 如果eval的参数不是字符串，那么会原样返回。 1eval(123) // 123 eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 1234var a = 1;eval(&apos;a = 2&apos;);a // 2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; &apos;use strict&apos;; eval(&apos;var foo = 123&apos;); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; &apos;use strict&apos;; var foo = 1; eval(&apos;foo = 2&apos;); console.log(foo); // 2&#125;)() 上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。 总之，eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析JSON数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法。 6.2 eval 的别名调用前面说过eval不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是eval。 123var m = eval;m(&apos;var x = 1&apos;);x // 1 上面代码中，变量m是eval的别名。静态代码分析阶段，引擎分辨不出m(&#39;var x = 1&#39;)执行的是eval命令。 为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 123456789var a = 1;function f() &#123; var a = 2; var e = eval; e(&apos;console.log(a)&apos;);&#125;f() // 1 上面代码中，eval是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。这样的话，引擎就能确认e()不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。 eval的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨eval()这一种形式是直接调用。 1234eval.call(null, &apos;...&apos;)window.eval(&apos;...&apos;)(1, eval)(&apos;...&apos;)(eval, eval)(&apos;...&apos;) 上面这些形式都是eval的别名调用，作用域都是全局作用域。 数组1. 定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 1var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; 上面代码中的a、b、c就构成一个数组，两端的方括号是数组的标志。a是0号位置，b是1号位置，c是2号位置。 除了在定义时赋值，数组也可以先定义后赋值。 12345var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。 123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 2. 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 1typeof [1, 2, 3] // &quot;object&quot; 上面代码表明，typeof运算符认为数组的类型就是对象。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。如果一个值总是先转成字符串，再进行赋值。 1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 上一章说过，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 3. length 属性数组的length属性，返回数组的成员数量。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。 12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 清空数组的一个有效方法，就是将length属性设为0。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length = 0;arr // [] 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 如果人为设置length为不合法的值，JavaScript 会报错。 1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。 1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 4. in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。 12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 5. for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for...in遍历数组。 数组的遍历可以考虑使用for循环或while循环。 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; 上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。 1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 6. 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位不影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 1234var a = [1, 2, 3,];a.length // 3a // [1, 2, 3] 上面代码中，数组最后一个成员后面有一个逗号，这不影响length属性的值，与没有这个逗号时效果一样。 数组的空位是可以读取的，返回undefined。 12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 7. 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。 12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。 1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c",
      "categories": [],
      "tags": []
    },
    {
      "title": "JS基本语法",
      "slug": "JS基本语法",
      "date": "2018-09-07T01:23:21.000Z",
      "updated": "2018-09-07T01:24:19.996Z",
      "comments": true,
      "path": "2018/09/07/JS基本语法/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/07/JS基本语法/",
      "excerpt": "",
      "text": "JS基本语法什么是 JavaScript 语言JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 1. 语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 2.变量2.1. 概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 2.2 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 3. 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 4. 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法： 单行注释，用//起头； 多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 5. 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 6. 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 6.1 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示 真，false表示 伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==）。 6.2 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world 6.3 switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”。 6.4 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 7. 循环语句循环语句用于重复执行某个操作，它有多种形式。 7.1 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; 7.2 for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 7.3 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); 7.4 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 7.5 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2",
      "categories": [],
      "tags": []
    },
    {
      "title": "学习jquery源码",
      "slug": "学习jquery源码",
      "date": "2018-09-07T01:21:00.000Z",
      "updated": "2018-09-07T01:22:20.550Z",
      "comments": true,
      "path": "2018/09/07/学习jquery源码/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/09/07/学习jquery源码/",
      "excerpt": "",
      "text": "学习jQuery源码笔记1. 立即执行函数IIFE (立即调用的函数表达,Immediately-Invoked Function Expression，简称IIFE) 123(function() &#123; /*code*/&#125;)() 或者123(function() &#123; /*code*/&#125;()) IIFE的作用 不必为函数命名，避免了污染全局变量我们这里直接对匿名函数使用这种“立即执行的函数表达式”，并且在函数的在括号内定义之后立刻调用执行，这样避免为函数命名，减少命名的冲突 IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。在的JavaScript语法中我们知道作用域分为全局作用域和函数作用域(当然在后面的ES6中引入了块级作用域)，依据函数作用域这一特点，在匿名函数中我们可以封装一些自己内部模块使用的私有变量。 例子1234(function () &#123; var a=10;&#125;)();alert(a); 会报错 a is not defined",
      "categories": [],
      "tags": []
    },
    {
      "title": "mac 下svn的使用",
      "slug": "mac-下svn的使用",
      "date": "2018-07-13T01:48:15.000Z",
      "updated": "2018-07-13T01:51:05.463Z",
      "comments": true,
      "path": "2018/07/13/mac-下svn的使用/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/07/13/mac-下svn的使用/",
      "excerpt": "",
      "text": "原来mac自带了svn，还挺好用的 以下是一些常用命令： 1、将文件checkout到本地目录 1 svn checkout path（path是服务器上的目录）2 例如：svn checkout svn://192.168.1.1/pro/domain3 简写：svn co 2、往版本库中添加新的文件 1 svn add file2 例如：svn add test.php(添加test.php)3 svn add *.php(添加当前目录下所有的php文件) 3、将改动的文件提交到版本库 1 svn commit -m “LogMessage“ [-N] [–no-unlock] PATH (如果选择了保持锁，就使用–no-unlock开关)2 例如： svn commit -m “add test file for my test“ test.php3 简写： svn ci 4、加锁/解锁 1 svn lock -m “LockMessage“ [–force] PATH2 例如：svn lock -m “lock test file“ test.php3 svn unlock PATH 5、更新到某个版本 1 svn update -r m path2 例如：3 svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。4 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)5 svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)6 简写：svn up 6、查看文件或者目录状态 1 1）svn status path（目录下的文件和子目录的状态，正常状态不显示）2 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】3 2）svn status -v path(显示文件和子目录状态)4 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。5 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。6 简写：svn st 7、删除文件 1 svn delete path -m “delete test fle“2 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”3 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种4 简写：svn (del, remove, rm) 8、查看日志 1 svn log path2 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、查看文件详细信息 1 svn info path2 例如：svn info test.php 10、比较差异 1 svn diff path(将修改的文件与基础版本比较)2 例如：svn diff test.php3 svn diff -r m:n path(对版本m和版本n比较差异)4 例如：svn diff -r 200:201 test.php5 简写：svn di 11、将两个版本之间的差异合并到当前文件 1 svn merge -r m:n path2 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、SVN 帮助 1 svn help2 svn help ci 13、版本库下的文件和目录列表 1 svn list path2 显示path目录下的所有属于版本库的文件和目录3 简写：svn ls 14、创建纳入版本控制下的新目录 复制代码 1 svn mkdir: 创建纳入版本控制下的新目录。2 用法: 1、mkdir PATH…3 2、mkdir URL…4 创建版本控制的目录。5 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增6 调度，以待下一次的提交。7 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。8 在这两个情况下，所有的中间目录都必须事先存在 复制代码 15、恢复本地修改 1 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:2 用法: revert PATH…3 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复4 被删除的目录 16、代码库URL变更 复制代码 1 svn switch (sw): 更新工作副本至不同的URL。 2 用法: 1、switch URL [PATH] 3 2、switch –relocate FROM TO [PATH…] 4 5 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 6 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 7 方法。 8 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 9 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用10 这个命令更新工作副本与仓库的对应关系。 复制代码 17、解决冲突 1 svn resolved: 移除工作副本的目录或文件的“冲突”状态。2 用法: resolved PATH…3 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的4 相关文件，然后让 PATH 可以再次提交。",
      "categories": [],
      "tags": []
    },
    {
      "title": "试一下Hexo Admin好不好用～",
      "slug": "试一下Hexo-Admin好不好用～",
      "date": "2018-07-12T04:23:00.000Z",
      "updated": "2018-07-12T04:24:41.990Z",
      "comments": true,
      "path": "2018/07/12/试一下Hexo-Admin好不好用～/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/07/12/试一下Hexo-Admin好不好用～/",
      "excerpt": "",
      "text": "觉得原始的发blog太麻烦，所以装了个hexo admin 现在来尝试下发下博客 1 2 3 发送！",
      "categories": [],
      "tags": []
    },
    {
      "title": "基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用",
      "slug": "个页面的大型单页面应用",
      "date": "2018-05-18T16:28:13.000Z",
      "updated": "2018-05-18T16:30:33.709Z",
      "comments": true,
      "path": "2018/05/19/个页面的大型单页面应用/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/19/个页面的大型单页面应用/",
      "excerpt": "",
      "text": "https://www.vue-js.com/topic/58abbd21a9c1282817afc28d github:https://github.com/bailicangdu/vue2-elm",
      "categories": [],
      "tags": []
    },
    {
      "title": "css3优惠券/邮票",
      "slug": "css3优惠券-邮票",
      "date": "2018-05-18T12:17:50.000Z",
      "updated": "2018-05-18T12:20:50.751Z",
      "comments": true,
      "path": "2018/05/18/css3优惠券-邮票/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/18/css3优惠券-邮票/",
      "excerpt": "",
      "text": "css3写的优惠券/邮票 码云地址：http://dflxm.gitee.io/code/%E9%82%AE%E7%A5%A8.html",
      "categories": [],
      "tags": [
        {
          "name": "css3",
          "slug": "css3",
          "permalink": "https://akitsukiwong.github.io/tags/css3/"
        }
      ]
    },
    {
      "title": "css3做banner",
      "slug": "css3做banner",
      "date": "2018-05-12T07:02:56.000Z",
      "updated": "2018-05-12T07:14:17.458Z",
      "comments": true,
      "path": "2018/05/12/css3做banner/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/12/css3做banner/",
      "excerpt": "",
      "text": "也是面试时候遇到的问题,回来随便弄了一个 在线地址：http://dflxm.oschina.io/code/ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;css3写一个banner&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; ul li &#123; list-style: none; &#125; .banner-box &#123; position: relative; width: 400px; height: 200px; overflow: hidden; &#125; .banner &#123; width: 1600px; position: absolute; left: 0; animation-name: bannerMove; animation-duration: 8s; animation-iteration-count: infinite; &#125; @keyframes bannerMove &#123; 0%, 30% &#123; left: 0; &#125; 35%, 65% &#123; left: -400px; &#125; 70%, 99% &#123; left: -800px; &#125; 100% &#123; left: -1200px; &#125; &#125; .banner li &#123; float: left; width: 400px; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;banner-box&quot;&gt; &lt;ul class=&quot;banner&quot;&gt; &lt;li style=&quot;background-color:#f90;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#f00;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#9f0;&quot;&gt;&lt;/li&gt; &lt;li style=&quot;background-color:#333;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;",
      "categories": [],
      "tags": [
        {
          "name": "css",
          "slug": "css",
          "permalink": "https://akitsukiwong.github.io/tags/css/"
        }
      ]
    },
    {
      "title": "css画三角形",
      "slug": "css画三角形",
      "date": "2018-05-12T06:13:43.000Z",
      "updated": "2018-05-12T06:52:27.693Z",
      "comments": true,
      "path": "2018/05/12/css画三角形/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/12/css画三角形/",
      "excerpt": "",
      "text": "面试时候遇到的问题，只要设置两个边框透明就行了,学会了这个，妈妈再也不怕我面试的时候被要求画三角形了 上三角 1234567#triangle-up &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid red;&#125; 下三角 1234567#triangle-down &#123;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 100px solid red;&#125; 左三角 1234567#triangle-left &#123;width: 0;height: 0;border-top: 50px solid transparent;border-right: 100px solid red;border-bottom: 50px solid transparent;&#125; 右三角 1234567#triangle-right &#123;width: 0;height: 0;border-top: 50px solid transparent;border-left: 100px solid red;border-bottom: 50px solid transparent;&#125;",
      "categories": [
        {
          "name": "代码片段",
          "slug": "代码片段",
          "permalink": "https://akitsukiwong.github.io/categories/代码片段/"
        }
      ],
      "tags": [
        {
          "name": "css",
          "slug": "css",
          "permalink": "https://akitsukiwong.github.io/tags/css/"
        }
      ]
    },
    {
      "title": "ECharts学习",
      "slug": "2018-05-12 ECharts学习",
      "date": "2018-05-12T06:10:04.000Z",
      "updated": "2018-05-27T03:41:40.374Z",
      "comments": true,
      "path": "2018/05/12/2018-05-12 ECharts学习/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/12/2018-05-12 ECharts学习/",
      "excerpt": "",
      "text": "面试了很多家单位，都问到了ECharts，所以准备一下还是很有必要的 2018-5-27 更新： 新单位也用到了ECharts，画了几个，也不难，官方文档也很全 主要就这几个步骤 引用js 准备放图表的容器 初始化图表，设置参数 有其它个性化要求，根据官方的文档，改一改配置项都可以快速解决",
      "categories": [
        {
          "name": "笔记",
          "slug": "笔记",
          "permalink": "https://akitsukiwong.github.io/categories/笔记/"
        }
      ],
      "tags": []
    },
    {
      "title": "CSS初始化",
      "slug": "2018-05-11 CSS初始化",
      "date": "2018-05-11T09:24:49.000Z",
      "updated": "2018-05-11T09:31:22.576Z",
      "comments": true,
      "path": "2018/05/11/2018-05-11 CSS初始化/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/11/2018-05-11 CSS初始化/",
      "excerpt": "",
      "text": "为什么初始化css?考虑到浏览器兼容性问题，不同浏览器对标签的默认值是不同的 通用初始化样式1234567891011121314151617181920212223242526272829303132333435body&#123; margin: 0;padding: 0;font-family: &quot;微软雅黑&quot;;overflow: hidden;&#125;body,html&#123;-webkit-text-size-adjust: none;width: 100%;height: 100%;&#125;*&#123;text-decoration: none;list-style: none;&#125;img&#123;border: 0px;&#125;ul,li,dl,dd,dt,p,ol,h1,h2,h3,h4,h5&#123;font-size: 12px;font-weight: 100;padding: 0;margin: 0;&#125;.wrap&#123;margin: 0 auto;&#125;.fl&#123;float: left;&#125;.fr&#123;float: right;&#125;.index&#123;overflow: hidden;&#125;.clr&#123;clear:both; height:0px; width:100%; font-size:1px; line-height:0px; visibility:hidden; overflow:hidden;&#125;.pointer&#123;cursor:pointer;&#125;a,input,button&#123; outline:none; &#125;::-moz-focus-inner&#123;border:0px;&#125;/*a:link &#123;color:#0f0;text-decoration:none;&#125; a:visited &#123;color: #FFFF00; text-decoration:none;&#125; a:hover &#123;color: #00FF00; text-decoration:underline;&#125; a:active &#123;color: #0000FF; text-decoration:underline;&#125;*/a&#123;color: #000;&#125;.wrapper&#123;clear: both;width: 100%;&#125;table &#123; border-collapse:collapse; &#125;word-break:break-all /*文字换行*//*white-space:nowrap 文字不换行*//*默认滚动条样式修改ie9 google Firefox 等高版本浏览器有效*//*::selection &#123;background: #D03333;color: white;text-shadow: none;&#125;::-webkit-scrollbar-track-piece&#123;width:10px;background-color:#f2f2f2&#125;::-webkit-scrollbar&#123;width:10px;height:6px&#125;::-webkit-scrollbar-thumb&#123;height:50px;background-color:rgba(0,0,0,.3);&#125;::-webkit-scrollbar-thumb:hover&#123;background:#cc0000&#125;*//*渐变*//*background-image: -moz-linear-gradient(top, #8fa1ff, #3757fa);background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #ff4f02), color-stop(1, #8f2c00)); Saf4+, Chrome filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#c6ff00&apos;, endColorstr=&apos;#538300&apos;, GradientType=&apos;0&apos;); IE*/ 另一种通用化样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* CSS Document */html, body, div, span, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,abbr, address, cite, code,del, dfn, em, img, ins,kbd, q, samp,small, strong, sub, sup, var,b, i,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot,thead,tr, th, td,article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary,time, mark, audio, video &#123; margin:0; padding:0; border:0; outline:0; font-size:100%; vertical-align:baseline; background:transparent; outline-style:none;/*FF*/ &#125;body &#123; line-height:1;&#125;a&#123; margin:0; padding:0; border:0; font-size:100%; vertical-align:baseline; background:transparent;&#125;a:hover,a:focus&#123; text-decoration:none; bblr:expression(this.onFocus=this.blur());/*IE*/ outline-style:none;/*FF*/ &#125;table &#123; border-collapse:collapse; border-spacing:0;&#125;input, select &#123; vertical-align:middle;&#125;/*css为clearfix，清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;&quot;; height: 0; line-height: 0; display: block; visibility: hidden; clear: both;&#125;.clearfix:after&#123;clear:both;&#125; .clearfix&#123; *zoom:1;/*IE/7/6*/&#125; 雅虎工程师提供的CSS初始化示例代码12345678910111213141516body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px&quot;宋体&quot;,&quot;Arial Narrow&quot;,HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:&quot;SimSun&quot;,&quot;宋体&quot;,&quot;Arial Narrow&quot;;&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化12345678910111213141516171819202122232425body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \\5b8b\\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px&quot;\\5B8B\\4F53&quot;,sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; 下面顺便给出admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; &lt;meta name=&quot;Author&quot; content=&quot;网页作者&quot; /&gt; &lt;meta name=&quot;Copyright&quot; content=&quot;网站版权&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述&quot; /&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;网站.ico图标路径&quot; /&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;CSS文件路径&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;",
      "categories": [
        {
          "name": "代码片段",
          "slug": "代码片段",
          "permalink": "https://akitsukiwong.github.io/categories/代码片段/"
        }
      ],
      "tags": [
        {
          "name": "css",
          "slug": "css",
          "permalink": "https://akitsukiwong.github.io/tags/css/"
        }
      ]
    },
    {
      "title": "常见前端面试题",
      "slug": "2018-05-10 常见前端面试题",
      "date": "2018-05-10T14:20:58.000Z",
      "updated": "2018-05-11T09:21:19.494Z",
      "comments": true,
      "path": "2018/05/10/2018-05-10 常见前端面试题/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/10/2018-05-10 常见前端面试题/",
      "excerpt": "",
      "text": "HTML什么是盒子模型？在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a、b、span、img、input、strong、select、label、em、button、textarea块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img 块元素与内联元素的区别？1.块元素，总是在新行上开始；内联元素，和其他元素都在一行上。 2.块元素，能容纳其他块元素或内联元素；内联元素，只能容纳文本或者其他内联元素。 3.块元素中高度，行高以及顶和底边距都可控制；内联元素中高，行高及顶和底边距不可改变。 常见的块级元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 CSSCSS实现垂直水平居中js如何理解闭包？定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 表现形式：使函数外部能够调用函数内部定义的变量。 jQuery相关jQuery库中的$()是什么？$()函数是jQuery()函数的别称。$()函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $()函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。 其它",
      "categories": [],
      "tags": [
        {
          "name": "面试",
          "slug": "面试",
          "permalink": "https://akitsukiwong.github.io/tags/面试/"
        }
      ]
    },
    {
      "title": "随便做的一个个人简历",
      "slug": "2018-05-10 随便做的一个个人简历",
      "date": "2018-05-10T07:44:58.000Z",
      "updated": "2018-05-11T09:07:22.744Z",
      "comments": true,
      "path": "2018/05/10/2018-05-10 随便做的一个个人简历/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/10/2018-05-10 随便做的一个个人简历/",
      "excerpt": "",
      "text": "码云page地址: http://dflxm.oschina.io",
      "categories": [],
      "tags": [
        {
          "name": "面试",
          "slug": "面试",
          "permalink": "https://akitsukiwong.github.io/tags/面试/"
        },
        {
          "name": "简历",
          "slug": "简历",
          "permalink": "https://akitsukiwong.github.io/tags/简历/"
        }
      ]
    },
    {
      "title": "hexo的常用命令",
      "slug": "2018-05-10 hexo的常用命令",
      "date": "2018-05-09T17:43:33.000Z",
      "updated": "2018-05-11T09:35:48.784Z",
      "comments": true,
      "path": "2018/05/10/2018-05-10 hexo的常用命令/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2018/05/10/2018-05-10 hexo的常用命令/",
      "excerpt": "",
      "text": "指令新建一篇文章1$ hexo new 新的文章名称 简写 1$ hexo n 新的文章名称 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: Hexokeywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 清除缓存文件 db.json 和已生成的静态文件 public1$ hexo clean 生成静态文件1$ hexo generate 简写 1$ hexo g 自动生成网站静态文件，并部署到设定的仓库1$ hexo deploy 简写 1$ hexo d 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ 1$ hexo s",
      "categories": [],
      "tags": [
        {
          "name": "hexo",
          "slug": "hexo",
          "permalink": "https://akitsukiwong.github.io/tags/hexo/"
        }
      ]
    },
    {
      "title": "rem.js",
      "slug": "2017-12-18 rem-js",
      "date": "2017-12-18T07:25:44.000Z",
      "updated": "2018-05-11T09:08:54.638Z",
      "comments": true,
      "path": "2017/12/18/2017-12-18 rem-js/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2017/12/18/2017-12-18 rem-js/",
      "excerpt": "",
      "text": "12345678910111213window.onload = function()&#123; /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是 为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/ getRem(750,100)&#125;;window.onresize = function()&#123; getRem(750,100)&#125;;function getRem(pwidth,prem)&#123; var html = document.getElementsByTagName(&quot;html&quot;)[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = oWidth/pwidth*prem + &quot;px&quot;;&#125;",
      "categories": [
        {
          "name": "代码片段",
          "slug": "代码片段",
          "permalink": "https://akitsukiwong.github.io/categories/代码片段/"
        }
      ],
      "tags": [
        {
          "name": "js",
          "slug": "js",
          "permalink": "https://akitsukiwong.github.io/tags/js/"
        },
        {
          "name": "rem",
          "slug": "rem",
          "permalink": "https://akitsukiwong.github.io/tags/rem/"
        }
      ]
    },
    {
      "title": "pc端移动端跳转js",
      "slug": "2017-12-18 pc端移动端跳转js",
      "date": "2017-12-17T17:43:33.000Z",
      "updated": "2018-05-11T09:47:51.590Z",
      "comments": true,
      "path": "2017/12/18/2017-12-18 pc端移动端跳转js/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2017/12/18/2017-12-18 pc端移动端跳转js/",
      "excerpt": "经常用到的跳转代码",
      "text": "经常用到的跳转代码 if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href=”你的手机版地址”;}else{ window.location.href=”你的电脑版地址”;}",
      "categories": [
        {
          "name": "代码片段",
          "slug": "代码片段",
          "permalink": "https://akitsukiwong.github.io/categories/代码片段/"
        }
      ],
      "tags": [
        {
          "name": "js",
          "slug": "js",
          "permalink": "https://akitsukiwong.github.io/tags/js/"
        },
        {
          "name": "跳转",
          "slug": "跳转",
          "permalink": "https://akitsukiwong.github.io/tags/跳转/"
        }
      ]
    },
    {
      "title": "javascript高级程序设计学习笔记",
      "slug": "2017-12-01 javascript高级程序设计学习笔记",
      "date": "2017-11-30T17:45:22.000Z",
      "updated": "2018-05-11T08:51:00.541Z",
      "comments": true,
      "path": "2017/12/01/2017-12-01 javascript高级程序设计学习笔记/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2017/12/01/2017-12-01 javascript高级程序设计学习笔记/",
      "excerpt": "",
      "text": "第一章 HTML中使用JavaScriptscript元素script中有六个属性 async charset defer language src type 标签的位置传统做法放在&lt;head&gt;中，js会被先加载页面会有延迟 所以把JavaScript引入放在&lt;body&gt;元素中页面元素的后面 这样先加载页面内容，用户会因为空白页面时间缩短而感到页面打开速度加快 延迟脚本HTML 4.01为&lt;script&gt;标签定义了defer属性。 相当于告诉浏览器立即下载延迟执行。 1&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; 异步脚本async 1&lt;script type=&apos;text/javascript&apos; async src=&apos;example.js&apos;&gt;&lt;/script&gt; 在XHTML中的用法XTML（可拓展超文本标记语言），是将HTML作为XML的应用而重新定于的一个标准规则比HTML严格 第二章 基本概念语法ECMAScript大量借鉴C及其他类C语言（Java等） 区分大小写ECMAScript中一切（变量、函数名和操作符）都区分大小写。 标识符标识符，指变量、函数、属性都名字，或者函数的参数。 第一个字符必须是字母、下划线（_）或者一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 注释C风格注释 123456// 单行注释/** 这是一个多行*（块级）注释*/ 严格模式ECMAScript 5 引入严格模式 启用严格模式可在顶部添加use strict; 1234function()&#123; &quot;use strict&quot;; //函数体&#125; 语句分号结尾；代码块{ } 里面 关键字和保留字变量ECMAScript的变量是松散类型的，可以保存任何类型的数据。 定义变量使用 var 操作符 函数中var的是局部变量，省略var是全局变量 定义多个变量（用逗号隔开） 123var message = &quot;hi&quot; , found = false , age = 29 ; 数据类型ES中有五种简单的数据类型 1- Undefined —– 未定义 2- Null ————- 3- Boolean ——– 布尔值 4- Number ——— 数值 5- String ———— 还有一种复杂数据类型 Object typeof 操作符12var message = &quot;some string&quot; ;alert(typeof message) ; //&quot;string&quot; typeof 返回值 undefined —— 为定义 boolean ——— 布尔值 string ———— 字符串 number ———- 数值 object ———— 对象 或者 null function ———- 函数 undefined 类型var 声明变量但为对其加以初始化的值就是undefined Null类型Boolean 类型true和false Number类型 整数和浮点数（带小数点的数值，小数点后至少有一位数字） 浮点数值极大极小的数字用e表示法（科学计数法） 12var floatNum = 3.125e7 //31250000var floatNum = 3e-17 //0.00000000000000003 浮点数值最高精度为17位小数，其计算精度远远不如整数，例如 0.1 + 0.2 结果不是 0.3 而是 0.300000000000004。 数值范围 Infinity （负无穷） Infinity （正无穷） NaN非数值 （not a number） 任何涉及NaN的操作都会返回NaN NaN和任何值都不相等，包括NaN 1alert（NaN == NaN） //false isNaN（）函数，查询是否为数值 123alert(isNaN(NaN)); //truealert(isNaN(10)); //false(10是一个数值)alert(isNaN(&quot;blue&quot;)) //true 数值转换 number() – 如果是布尔值，返回0和1 – 如果是数字，简单的传入和返回 – 如果是null，返回0 – 如果是undefined，返回NaN – 如果是字符串……… – 如果是对象，调用valueOf( ) 方法，如果转换的对象是NaN，调用toString（）方法 parseInt() parseFloat() string 类型单引号和双引号字符串形式完全相同 字符字面量string数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符 \\n 换行 \\t 制表 \\b 退格 等… 字符串的特点ES中字符串是不可变的，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充改变量。 转换为字符串toString（） Object 类型对象其实就是一组数据和功能的集合。对象可以通过new操作符来创建 1var o = new Object( ) ; （括号可以省略，但不推荐） 操作符一元操作符只能操作一个值但操作符叫做一元操作符。 递增和递减操作符++age；等于age = age +1; –age; 等于age = age - 1； 【前置型】会影响语句的结果，求值之前执行 【后置型】不会影响语句结果，求值之后执行 例子 1234var num1 = 2 ;var num2 = 20 ;var num3 = --num + num2 ; //21var num4 = num1 + num2 ; //21 1234var num1 = 2 ;var num2 = 20 ;var num3 = num-- + num2 ; //22var num4 = num1 + num2 ; //21 一元加和减操作符一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。 12var num = 25 ;num = +num ; //25 一元减操作符主要表示负数。 位操作符转化位二进制 12var num = -18 ;alert(num.toString(2)) ; //&quot;-10010&quot; 按位非（NOT）按位非由一个波浪号【～】表示，执行按位非的结果就是返回数值的反码（二进制逐位取反） 按位与（AND）按位与由一个和字符号【&amp;】表示，都是1返回1，有0就返回0 按位或（OR）按位或由一个竖线符号【|】表示，有1返回1，都是0才返回0 左移【&lt;&lt;】，会将数值的所有位向左移动制定的位数。 12var oldValue = 2 ; //二进制10var newValue = oldValue &lt;&lt; 5; //二进制100000，即64 右移【&gt;&gt;】,会将数值向右移动，但保留符号位 12var oldValue = 64 ; //二进制1000000var newValue = oldValue &gt;&gt; 5; //二进制10，即2 无符号右移【&gt;&gt;&gt;】，会将数值的所有32位都向右移动。 对于正数于【&gt;&gt;】一样，对于负数无符号右移后结果会变得非常大，因为无符号右移会移动所有的二进制码。 12var oldValue = -64 ; //二进制1000000var newValue = oldValue &gt;&gt;&gt; 5; //十进制134217726 3.5.3 布尔操作符布尔操作符一共三个 非（NOT）【 ！】 与（AND） 【 &amp;&amp; 】 或（OR） 【 || 】 乘性操作符 乘法 【 * 】 除法 【 / 】 求模 （余数） 【 % 】 1var result = 26 % 5 ; //等于 1 加性操作符 加法 【 + 】 减法 【 - 】 关系操作符 小于 【 &lt; 】 大于 【 &gt; 】 小于等于 【 &lt;= 】 大于等于 【 &gt;= 】 相等操作符相等和不相等（先转换再比较） 全等和不全等（仅比较不转换） 相等和不相等 相等 【 == 】 不相等 【 != 】 全等和不全等 全等 【 === 】 不全等 【 !== 】 条件操作符1variable = boolean_expression ? true_value : false_value 基于对boolean_expression求值对结果，决定给变量variable赋什么值。如果为true，赋true_value值，如果为false，赋false_value值 1var max = (num1 &gt; num2) ? num1 : num2 ; max将保存最大对值，表达式意思是：如果num1大于num2，给max赋num1值，反之赋值num2 赋值操作符简单赋值操作符由符号【 = 】表示，作用：把右侧对值赋给左侧对变量 逗号操作符可以在一条语句中执行多个操作 1var num1 = 1, num2 = 2, num3 = 3; 逗号操作符还可以用作赋值，会返回表达式对最后一项。 1var num = ( 5, 1, 4, 8, 0); //num的值为0，因为0是表达式的最后一项 语句if语句12345if ( condition【条件】 ) &#123; statement1【语句1】； &#125; else &#123; statement【语句2】； &#125; 1234567if( condition1【条件1】 )&#123; statement1【语句1】；&#125; else if ( condition2【条件2】 )&#123; statemen2【语句2】；&#125; else &#123; statement3【语句3】；&#125; do-while 语句12345do&#123; statement【语句】&#125; while &#123; expression【条件】&#125; while 语句123while( expression【条件】 )&#123; statement【语句】&#125; for语句for语句也是一种前端测试循环语句，它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。 123for(initialization【初始化】; expression【条件】; post-loop-expression【循环表达式】)&#123; statement【语句】;&#125; 当三个表达式全部省略就会创建一个无限循环 123for( ; ; )&#123; //无限循环 doSomething();&#125; 3.6.5 for-in语句for-in语句是一种精准当迭代语句，可以用来枚举对象当属性。 123for( property【属性】 in expression)&#123; statement【语句】&#125; 3.6.6 label语句1label【标签】: statement 123start: for (var i = 0; i &lt; count; i++)&#123; alert(i);&#125; 3.6.7 break和continue语句break和continue用于在循环中精确的控制代码的执行【break】立即退出循环，强制继续执行循环后面的语句【continue】立即退出循环，退出循环后会从循环的顶部继续执行break和continue都可以和label语句联合使用，从而返回代码中特定的位置。 3.6.8 with语句123with(expreession【条件】)&#123; statement【语句】&#125; with语句主要目的是为了简化多次编写同一个对象的工作123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 以上代码都包含了location对象，用with语句12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 不建议使用过with语句 3.6.9 switch 语句1234567891011switch(expression)&#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; 相当于if-else语句简化写法123456789if(i == 25)&#123; alert(&quot;25&quot;);&#125; else if(i == 35)&#123; alert(&quot;35&quot;)&#125; else if(i == 45)&#123; alert(&quot;45&quot;)&#125;else &#123; alert(&quot;other&quot;)&#125; 等价于switch语句12345678910111213switch( i )&#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;35&quot;); break; case 45: alert(&quot;45&quot;); break; default: alert(&quot;other&quot;);&#125; 3.7 函数123function functionName(arg0, arg1, ...,argN)&#123; statements&#125; 位于语句之后都任何代码都永远不会执行 3.7.1 理解参数命名的参数只提供便利，但不是必须的 3.7.2 没有重载第三章 变量、作用域和内存问题4.1 基本类型和引用类型的值【基本类型】简单的数据段【引用类型】可能有多个值构成的对象 4.1.1 动态的属性4.1.2 复制变量值4.1.3 传递参数当在函数内部重写obj时，这个变量引用的就是一个局部对象，这个局部对象会在函数执行完毕后立即销毁。12345678function setName(obj)&#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();set.Name(person);alert(person.name); //&quot;Nicholas&quot; 4.1.4 检测类型instanceof操作符1result = variable instanceof constructor 例子123alert(person instanceof Object); //变量person是Object吗？alert(colors instanceof Array); //变量colors是Array吗？alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ 4.2 执行环境及作用域延长作用域链4.2.2 没有块级作用域声明变量使用var声明的变量会自动添加到最接近到环境中如果初始化变量没有使用var 声明，该变量会自动被添加到全局环境。 查询标识符4.3 垃圾收集js具有垃圾自动收集功能 4.3.1 标记清除4.3.2 引用计数4.3.3 性能问题4.3.4 管理内存第五章 引用类型5.1 Object类型创建Object实例有两种方式 使用new操作符后跟Object构造函数123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; Object可以省略，用大括号代替123var person = &#123;&#125;;person.name = &quot;Nicholas&quot;;person.age = &quot;29&quot;; 使用对象字面量表示法，是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。1234var person = &#123; name = &quot;Nicholas&quot; , age = 29&#125;; 访问对象属性可以用点表示法，也可以用方括号12alert(person.name); //Nicholasalert(person[&quot;name&quot;]); //Nicholas 方括号语法的主要优点是可以通过变量来访问属性12var propertyName = &quot;name&quot;;alert(person[propertyName]); //Nicholas 5.2 array类型创建数组有两种方法1var colors = new Array(); 创建length值为20的数组1var colors = new Array( 20 ); 也可以向Array构造函数传递数组中应该包含的项1var colors = new Array( &quot;red&quot;,&quot;blue&quot;,&quot;green&quot; ); 可以省略new操作符1var colors = Array(); 可以使用字面量表示法，数组用方括号表示，逗号隔开12var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; var names = [] //创建一个空数组 利用length属性可以方便的在数组末尾添加新项123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; colors[colors.length] = &quot;black&quot;; //在位置3添加一种颜色colors[colors.length] = &quot;brown&quot; //在位置4添加一种颜色 5.2.1 检测数组123if(value instanceof Array)&#123; //do something&#125; ES5新增的Array.isArray()方法，用于确定某个值到底是不是数组，而不管它是在哪个全局环境下创建的。123if(Array.isArray(value))&#123; //do something&#125; 5.2.2 转换方法join方法可以使用不同的分隔符来构建这个字符串join方法只接受一个参数，用作分隔符的字符串123var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];alert(colors.join(&quot;,&quot;)); //red,blue,greenalert(colors.join(&quot;||&quot;)); //red||blue||green 5.2.3 栈方法栈是一种【LOFO】后进先出的数据结构栈中 插入叫做推入，移除叫做弹出 push() 接收任意数量的参数逐个添加到数组末尾（从末尾加）pop() 从数组末尾移除最后一项（删最后一个） 5.2.4 队列方法队列是【FIFO】先进先出 shift() 移除数组中的第一个项（删第一个）unshift() 在数组前端添加任意个项（从前面加） 5.2.5 重排列方法reverse() 翻转数组项的顺序sort() 升序排列（首字母排序，不是按大小） 比较函数 升序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序1function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 5.2.6 操作方法concat() 末尾添加数组 splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数）splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项)splice( 2, 0, &quot;red&quot;, &quot;green&quot; ) 从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项)splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green”例子 1var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var removed = colors.splice(0,1); //remove the first item alert(colors); //green,blue alert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1 alert(colors); //green,yellow,orange,blue alert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove one alert(colors); //green,red,purple,orange,blue alert(removed); //yellow - one item array 5.2.7 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1]; alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 5.2.8 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 21234567var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 5.2.9 归并方法reduce() 从数组第一项开始逐个遍历到最后reduceRight() 从数组最后一项开始，向前遍历到第一项四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和12345var values = [1,2,3,4,5]; var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5]; var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur; &#125;); alert(sum); 5.3 Data 类型Data.parse()-接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数Data.UTC()-同样返回日期的毫秒数，但参数分别是年份、基于0但月份（一月是0，二月是1…）、月中的哪一天（1-31）、小时数（0-23）、分钟、秒、毫秒数。只有前两个参数，年和月是必须的 12345//GMT时间2000年1月1日午夜零时var y2k = new Data(Data.UTC(2000,0));//GMT时间2005年5月5日下午5:55:55var allFive = new Data(Data.UTC(2005,4,5,17,55,55)); ES5中添加来Data.now()方法 5.3.1 继承的方法",
      "categories": [
        {
          "name": "前端学习",
          "slug": "前端学习",
          "permalink": "https://akitsukiwong.github.io/categories/前端学习/"
        }
      ],
      "tags": [
        {
          "name": "js",
          "slug": "js",
          "permalink": "https://akitsukiwong.github.io/tags/js/"
        }
      ]
    },
    {
      "title": "数组常用方法",
      "slug": "2017-11-20 数组常用方法",
      "date": "2017-11-20T07:04:48.000Z",
      "updated": "2018-05-11T09:43:03.292Z",
      "comments": true,
      "path": "2017/11/20/2017-11-20 数组常用方法/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2017/11/20/2017-11-20 数组常用方法/",
      "excerpt": "",
      "text": "栈方法push() 接收任意数量的参数逐个添加到数组末尾（从末尾加） pop() 从数组末尾移除最后一项（删最后一个） 队列方法shift() 移除数组中的第一个项（删第一个） unshift() 在数组前端添加任意个项（从前面加） 重排列方法reverse() 翻转数组项的顺序 sort() 升序排列（首字母排序，不是按大小） 比较函数升序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //0,1,5,10,15 降序12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); //15,10,5,1,0 操作方法concat() 末尾添加数组 1contan( [ &quot;black&quot; , &quot;yellow&quot; , &quot;red&quot; ] ) splice() 数组中部插入项 删除splice（要删除的第一项的位置， 要删除的项数） splice( 0, 2 ) 删除数组中前两项 插入splice( 起始位置， 0（要删除的项数）， 要插入的项) splice( 2, 0, &quot;red&quot;, &quot;green&quot; )从当前数组的位置2 开始插入字符串“red” 和“green” 替换splice( 起始位置， 要删除的项数， 要插入的任意数量的项) splice( 2, 1, &quot;red&quot;, &quot;green&quot; ) 会删除当前数组位置 2 的项， 然后再从位置 2 开始插入字符串 “red” 和“green” 例子 123456789101112var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1alert(colors); //green,yellow,orange,bluealert(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove onealert(colors); //green,red,purple,orange,bluealert(removed); //yellow - one item array 位置方法indexOf() 从数组的开头（位置0）开始向后查找， 没找到的情况下会返回-1 lastIndexOf 从数组的末尾开始向前查找， 没找到的情况下会返回-1 例子 1234567891011121314var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5 alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3 var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person]; alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person)); //0 迭代方法every() 对数组中的每一项运行给定函数， 如果该函数对每一项都返回true， 则返回true。 filter() 对数组中的每一项运行给定函数， 返回该函数会返回 true 的项组成的数组。 forEach() 对数组中的每一项运行给定的函数。 这个方法没有返回值。 map() 对数组中的每一项运行给定的函数， 返回每次函数调用的结果组成的数组。 some() 对数组中的每一项运行给定的函数， 如果该函数对任一项返回true， 则返回true。 以上方法都不会修改数组中的包含的值， 传入这些方法会接受三个参数（数组项的值， 该项在数组中的位置， 数组对象本身） every() some() 例子以上代码调用的every() 和 some() ， 传入的函数只要给定项大于 2 就会返回true， 对于every()，它返回的是false， 因为只有部分数组项符合条件，对于some() 就返回true， 因为至少有一项是大于 2 的。 12345678910111213var numbers = [1,2,3,4,5,4,3,2,1]; var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); //false var someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true filter() 例子通过filter（）方法创建并返回一个所有数值都大于 2 的数组 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3] map() 例子给数组中每一项都乘以 2 1234567var numbers = [1,2,3,4,5,4,3,2,1]; var mapResult = numbers.map(function(item, index, array)&#123; return item * 2; &#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2] forEach() 例子1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;) 归并方法reduce() 从数组第一项开始逐个遍历到最后 reduceRight() 从数组最后一项开始，向前遍历到第一项 四个参数（前一个值， 当前值， 项的索引， 数组对象） reduce() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight() 例子求数组所有值之和 12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum);",
      "categories": [
        {
          "name": "前端学习",
          "slug": "前端学习",
          "permalink": "https://akitsukiwong.github.io/categories/前端学习/"
        }
      ],
      "tags": [
        {
          "name": "数组",
          "slug": "数组",
          "permalink": "https://akitsukiwong.github.io/tags/数组/"
        },
        {
          "name": "js",
          "slug": "js",
          "permalink": "https://akitsukiwong.github.io/tags/js/"
        }
      ]
    },
    {
      "title": "Markdown学习",
      "slug": "2017-11-13 Markdown学习",
      "date": "2017-11-13T07:16:21.000Z",
      "updated": "2018-05-11T08:51:14.991Z",
      "comments": true,
      "path": "2017/11/13/2017-11-13 Markdown学习/",
      "link": "",
      "permalink": "https://akitsukiwong.github.io/2017/11/13/2017-11-13 Markdown学习/",
      "excerpt": "",
      "text": "一级标题H1二级标题H2三级标题H3四级标题H4五级标题H5六级标题H6无序列表 列表1 列表2 列表3 或者 列表1 列表1 列表1 再或者 列表1 列表1 列表1 引用 这个样子引用，啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 还有个二级的引用，哈哈哈哈哈哈哈哈哈哈哈哈或或或或或或或或或或或或或或或或或或或或或 三级的引用，看了啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦 回归一级吧，记得要空一行 例子 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码区块这是一个普通段落： 这是一个代码区块。 前面一个制表符就是代码 或者四个空格 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理 分割线 链接I get 10 times more traffic from Google than fromYahoo or MSN. I get 10 times more traffic from Google than fromYahoo or MSN. 一小段代码Use the printf() function.There is a literal backtick (`) here.A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz",
      "categories": [],
      "tags": [
        {
          "name": "Markdown",
          "slug": "Markdown",
          "permalink": "https://akitsukiwong.github.io/tags/Markdown/"
        }
      ]
    }
  ]
}